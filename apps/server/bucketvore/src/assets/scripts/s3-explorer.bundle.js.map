{"version":3,"file":"s3-explorer.bundle.js","mappings":"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","sources":["webpack://onivoro/./apps/server/bucketvore/src/app/client/s3-explorer.client.ts","webpack://onivoro/./apps/server/bucketvore/src/app/client/utils/clipboard.client.ts"],"sourcesContent":["/**\n * S3 Explorer Alpine.js Component\n * Client-side TypeScript with full IDE support\n */\n\nimport { copyS3PathToClipboard } from './utils/clipboard.client';\nimport type { S3ClientState, UploadProgress } from '../shared/types.shared';\n\ndeclare global {\n  interface Window {\n    Alpine: any;\n  }\n}\n\nexport function s3Explorer(): S3ClientState & Record<string, any> {\n  return {\n    // State\n    selectedBucket: '',\n    currentPrefix: '',\n    buckets: [],\n    files: [],\n    folders: [],\n    viewMode: 'list',\n    bucketsHtml: '<div class=\"loading\"><div class=\"spinner\"></div><p>Loading buckets...</p></div>',\n    filesHtml: '',\n    breadcrumbsHtml: '',\n    bucketFilter: '',\n    fileFilter: '',\n    showUpload: false,\n    showPreview: false,\n    uploadProgress: [] as UploadProgress[],\n    uploadProgressHtml: '',\n    previewHtml: '',\n    activeTab: 'data',\n\n    // Computed properties\n    get filteredBucketsHtml(): string {\n      if (!this.bucketFilter.trim()) {\n        return this.bucketsHtml;\n      }\n\n      const parser = new DOMParser();\n      const doc = parser.parseFromString(this.bucketsHtml, 'text/html');\n      const bucketItems = doc.querySelectorAll('.bucket-item');\n\n      bucketItems.forEach((item) => {\n        const bucketName = item.querySelector('.bucket-name')?.textContent?.toLowerCase() || '';\n        if (bucketName.includes(this.bucketFilter.toLowerCase())) {\n          (item as HTMLElement).style.display = '';\n        } else {\n          (item as HTMLElement).style.display = 'none';\n        }\n      });\n\n      const visibleCount = doc.querySelectorAll('.bucket-item:not([style*=\"display: none\"])').length;\n      if (visibleCount === 0) {\n        return '<div class=\"empty-state\"><div class=\"empty-state-icon\">üîç</div><p>No buckets match your filter</p></div>';\n      }\n\n      return doc.body.innerHTML;\n    },\n\n    get filteredFilesHtml(): string {\n      if (!this.fileFilter.trim() || !this.filesHtml) {\n        return this.filesHtml;\n      }\n\n      const parser = new DOMParser();\n      const doc = parser.parseFromString(this.filesHtml, 'text/html');\n      const fileItems = doc.querySelectorAll('.file-item');\n\n      fileItems.forEach((item) => {\n        const fileName = item.querySelector('.file-name')?.textContent?.toLowerCase() || '';\n        if (fileName.includes(this.fileFilter.toLowerCase())) {\n          (item as HTMLElement).style.display = '';\n        } else {\n          (item as HTMLElement).style.display = 'none';\n        }\n      });\n\n      const visibleCount = doc.querySelectorAll('.file-item:not([style*=\"display: none\"])').length;\n      if (visibleCount === 0) {\n        return '<div class=\"empty-state\"><div class=\"empty-state-icon\">üîç</div><p>No files match your filter</p></div>';\n      }\n\n      return doc.body.innerHTML;\n    },\n\n    // Initialization\n    async init(): Promise<void> {\n      await this.loadBuckets();\n    },\n\n    // API Methods\n    async loadBuckets(): Promise<void> {\n      try {\n        const response = await fetch('/api/buckets');\n        this.bucketsHtml = await response.text();\n      } catch (error) {\n        this.bucketsHtml = '<div class=\"error\"><div class=\"error-icon\">‚ö†Ô∏è</div><p>Error loading buckets</p></div>';\n      }\n    },\n\n    async selectBucket(bucketName: string): Promise<void> {\n      this.selectedBucket = bucketName;\n      this.currentPrefix = '';\n      this.fileFilter = '';\n      await this.loadFiles();\n    },\n\n    async loadFiles(): Promise<void> {\n      try {\n        const params = new URLSearchParams({\n          bucket: this.selectedBucket,\n          prefix: this.currentPrefix\n        });\n\n        const response = await fetch(`/api/files?${params}`);\n        const data = await response.json();\n\n        this.filesHtml = data.filesHtml || '';\n        this.breadcrumbsHtml = data.breadcrumbsHtml || '';\n      } catch (error) {\n        this.filesHtml = '<div class=\"error\"><div class=\"error-icon\">‚ö†Ô∏è</div><p>Error loading files</p></div>';\n      }\n    },\n\n    async navigateToFolder(prefix: string): Promise<void> {\n      this.currentPrefix = prefix;\n      this.fileFilter = '';\n      await this.loadFiles();\n    },\n\n    async previewFile(key: string): Promise<void> {\n      try {\n        const params = new URLSearchParams({\n          bucket: this.selectedBucket,\n          key: key\n        });\n\n        const response = await fetch(`/api/files/preview?${params}`);\n        this.previewHtml = await response.text();\n        this.showPreview = true;\n      } catch (error) {\n        alert('Error loading preview');\n      }\n    },\n\n    closePreview(): void {\n      this.showPreview = false;\n      this.previewHtml = '';\n    },\n\n    async downloadFile(key: string): Promise<void> {\n      try {\n        const params = new URLSearchParams({\n          bucket: this.selectedBucket,\n          key: key\n        });\n\n        const response = await fetch(`/api/files/download?${params}`);\n        const data = await response.json();\n        window.open(data.url, '_blank');\n      } catch (error) {\n        alert('Error generating download link');\n      }\n    },\n\n    async deleteFile(key: string): Promise<void> {\n      if (!confirm(`Delete ${key}?`)) return;\n\n      try {\n        await fetch(`/api/files/delete`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ bucket: this.selectedBucket, key })\n        });\n        await this.loadFiles();\n      } catch (error) {\n        alert('Error deleting file');\n      }\n    },\n\n    async copyS3Path(key: string): Promise<void> {\n      const element = (event as any)?.target as HTMLElement | undefined;\n      await copyS3PathToClipboard(this.selectedBucket, key, element);\n    },\n\n    async deleteFolder(prefix: string): Promise<void> {\n      if (!confirm(`Delete folder ${prefix} and all its contents?`)) return;\n\n      try {\n        await fetch(`/api/files/delete-folder`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ bucket: this.selectedBucket, prefix })\n        });\n        await this.loadFiles();\n      } catch (error) {\n        alert('Error deleting folder');\n      }\n    },\n\n    // Upload functionality\n    handleFileSelect(event: Event): void {\n      const input = event.target as HTMLInputElement;\n      if (input.files) {\n        const files = Array.from(input.files);\n        this.uploadFiles(files);\n      }\n    },\n\n    handleDrop(event: DragEvent): void {\n      (event.target as HTMLElement).classList.remove('drag-over');\n      if (event.dataTransfer?.files) {\n        const files = Array.from(event.dataTransfer.files);\n        this.uploadFiles(files);\n      }\n    },\n\n    async uploadFiles(files: File[]): Promise<void> {\n      this.uploadProgress = files.map(f => ({ name: f.name, status: 'Uploading...' }));\n\n      for (let i = 0; i < files.length; i++) {\n        const file = files[i];\n        const formData = new FormData();\n        formData.append('file', file);\n        formData.append('bucket', this.selectedBucket);\n        formData.append('prefix', this.currentPrefix);\n\n        try {\n          await fetch('/api/upload', {\n            method: 'POST',\n            body: formData\n          });\n          this.uploadProgress[i].status = '‚úì Complete';\n        } catch (error) {\n          this.uploadProgress[i].status = '‚úó Failed';\n        }\n      }\n\n      setTimeout(async () => {\n        this.uploadProgress = [];\n        this.showUpload = false;\n        await this.loadFiles();\n      }, 2000);\n    },\n\n    async refresh(): Promise<void> {\n      await this.loadFiles();\n    },\n\n    filterBuckets(): void {\n      // Reactive computed property handles this\n    },\n\n    filterFiles(): void {\n      // Reactive computed property handles this\n    }\n  };\n}\n\n// Auto-register with Alpine when it initializes\nif (typeof window !== 'undefined') {\n  // Register immediately if Alpine is already available\n  if ((window as any).Alpine) {\n    (window as any).Alpine.data('s3Explorer', s3Explorer);\n  } else {\n    // Otherwise wait for Alpine to initialize\n    document.addEventListener('alpine:init', () => {\n      (window as any).Alpine.data('s3Explorer', s3Explorer);\n    });\n  }\n}\n","/**\n * Client-side utility for clipboard operations\n */\n\nexport async function copyToClipboard(text: string, element?: HTMLElement): Promise<boolean> {\n  try {\n    await navigator.clipboard.writeText(text);\n\n    // Provide visual feedback if element is provided\n    if (element) {\n      const originalText = element.textContent || '';\n      const originalBg = element.style.backgroundColor;\n\n      element.textContent = '‚úì Copied!';\n      element.style.backgroundColor = 'var(--color-success)';\n\n      setTimeout(() => {\n        element.textContent = originalText;\n        element.style.backgroundColor = originalBg;\n      }, 1500);\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Clipboard API failed:', error);\n\n    // Fallback to prompt\n    const userCopy = prompt('Copy to clipboard:', text);\n    return userCopy !== null;\n  }\n}\n\nexport async function copyS3PathToClipboard(\n  bucket: string,\n  key: string,\n  element?: HTMLElement\n): Promise<void> {\n  try {\n    // Fetch bucket region\n    const response = await fetch(`/api/buckets/${encodeURIComponent(bucket)}/region`);\n    const data = await response.json();\n    const region = data.region || 'us-east-1';\n\n    // Construct HTTPS URL\n    const url = `https://s3.${region}.amazonaws.com/${bucket}/${key}`;\n\n    await copyToClipboard(url, element);\n  } catch (error) {\n    console.error('Error getting S3 URL:', error);\n\n    // Fallback to s3:// protocol\n    const s3Path = `s3://${bucket}/${key}`;\n    prompt('Copy S3 path (fallback):', s3Path);\n  }\n}\n"],"names":["s3Explorer","selectedBucket","currentPrefix","buckets","files","folders","viewMode","bucketsHtml","filesHtml","breadcrumbsHtml","bucketFilter","fileFilter","showUpload","showPreview","uploadProgress","uploadProgressHtml","previewHtml","activeTab","filteredBucketsHtml","this","trim","doc","DOMParser","parseFromString","querySelectorAll","forEach","item","querySelector","textContent","toLowerCase","includes","style","display","length","body","innerHTML","filteredFilesHtml","init","loadBuckets","response","fetch","text","error","selectBucket","bucketName","loadFiles","params","URLSearchParams","bucket","prefix","data","json","navigateToFolder","previewFile","key","alert","closePreview","downloadFile","window","open","url","deleteFile","confirm","method","headers","JSON","stringify","copyS3Path","element","event","target","async","encodeURIComponent","region","navigator","clipboard","writeText","originalText","originalBg","backgroundColor","setTimeout","console","prompt","copyToClipboard","copyS3PathToClipboard","deleteFolder","handleFileSelect","input","Array","from","uploadFiles","handleDrop","classList","remove","dataTransfer","map","f","name","status","i","file","formData","FormData","append","refresh","filterBuckets","filterFiles","Alpine","document","addEventListener"],"sourceRoot":""}